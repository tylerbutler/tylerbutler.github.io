<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js"> <!--<![endif]-->
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>    Ten Things Steve Bennett Hates About Git    : Tyler Butler
</title>

                    
    <link rel="alternate" type="application/atom+xml"
          title="Tyler Butler Atom Feed"
          href="/feeds/atom.xml"/>

                
                                                        <link rel="stylesheet"
                      href="/static/engineer/lib/foundation/stylesheets/grid.css">
                <link rel="stylesheet"
                      href="/static/engineer/lib/foundation/stylesheets/mobile.css">

                <!--[if lt IE 9]>
                    <link rel="stylesheet" href="/static/engineer/lib/foundation/stylesheets/ie.css">
                <![endif]-->
                        
                    
                    
                    <link rel="stylesheet" href="/static/theme/stylesheets/dark_rainbow.css" type="text/css"/>
        
                
                                    
            <script type="text/javascript"
            src="http://use.typekit.net/vty2qol.js"></script>
    <script type="text/javascript">
        try {
            Typekit.load();
        }
        catch (e) {
        }
    </script>
    
            <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-26061862-1']);
    _gaq.push(['_setDomainName', 'tylerbutler.com']);

    // track speed for all users; traffic is low enough this shouldn't be a problem
    _gaq.push(['_setSiteSpeedSampleRate', 100]);
    
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>    
                        <script src="/static/engineer/lib/modernizr-2.6.2.min.js"
                    type="text/javascript"></script>
            
            <!-- Grab Google CDN's jQuery, with a protocol relative URL; fall back to local if offline -->
            <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
            <script>
                window.jQuery || document.write('<script src="/static/engineer/lib/jquery-1.10.2.min.js"><\/script>')
            </script>    
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
</head>
<body class=""><!--[if lt IE 7]>
    <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
<![endif]-->    <div class="container">            <header id="primary" class="row">                                            <h1 class="five columns">
                            <a href="/">                                    tyler
                                    <span class="highlight">butler</span>
                                </a>
                        </h1>
                                                        <nav class="seven columns">                            <ul class="nav navbar-nav">
    
                <li class="current">
        <a href="/">articles</a></li>
                <li>
        <a href="/projects">projects</a></li>
</ul>

                        </nav>
                </header>
        <div class="row">                <section id="main" class="twelve columns"
                         role="main">    <div class="row">
            <div class="post-info two columns">
            <div class="post-date">
                                    <div class="month">AUG</div>
                    <div class="day">05</div>
                    <div class="year">2012</div>
                    <div class="permalink">
                        <a href="/2012/08/ten-things-steve-bennett-hates-about-git/"
                           title="Permanent link to 'Ten Things Steve Bennett Hates About Git'">∞</a>
                    </div>
                            </div>
                            <div class="attribution">
                                            via <a href="https://twitter.com/codinghorror/statuses/231982243109822464">Jeff Atwood</a>
                                    </div>
                                        <ul class="tags">
                                            <li><a href="/tag/git">git</a>
                        </li>
                                    </ul>
                    </div>
                            <article class="post-content ten columns">
                <time datetime="2012-08-05 PDT"
                      pubdate=""></time>
                <header>
                    <h1>
                        <a href="https://steveko.wordpress.com/2012/02/24/10-things-i-hate-about-git/">Ten Things Steve Bennett Hates About Git</a>
                        <span class="arrow">→</span>                    </h1>
                </header>
                                    <p>For whatever reason, I&#8217;ve seen this relatively old article from Steve Bennett linked to by several people over the last day or so. It&#8217;s definitely worth a read, and I agree with a lot of it. But I think Bennett misses the mark in a few&nbsp;places.</p>
<p>First, the things I agree&nbsp;with:</p>
<h2>Yes, the command line and official Git documentation&nbsp;suck.</h2>
<p>I&#8217;ve <a href="/2012/06/10/git-vs-mercurial-again/">complained about this before</a>. Software engineers like to believe that if we know how to do one thing, then we can work out how to do all similar things quickly by applying that knowledge. After all, software engineering is advanced problem solving and critical thinking, so applying previous knowledge to current problems is something we&#8217;re pretty good&nbsp;at. </p>
<p>Frankly, the Git command line breaks this all the time. Some commands need some flags; others don&#8217;t. Conceptually similar operations require different top-level commands (not just flags) depending on what you&#8217;re doing that operation on.<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup> It&#8217;s madness, and I think it&#8217;s safe to say that the command line isn&#8217;t <em>designed</em>; it&#8217;s merely <em>implemented.</em></p>
<!-- more -->

<p>Similarly, the documentation sucks. I have found that a major challenge with documenting an application, even <a href="/projects/engineer/">one whose primary interface is a command line</a>, is documenting things for both a <em>user</em> and a <em>potential contributor</em>. With <a href="/projects/engineer/">Engineer</a>, I try to keep the two types separate, but it&#8217;s a challenge. Arguably open-source software tends to have this problem more &#8211; or at least it&#8217;s more publically evident<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup> &#8211; since the point of the software is two-fold: to be useful to users, and to attract additional developers to&nbsp;contribute.</p>
<p>In Git&#8217;s case, the official documentation seems to be more focused on potential contributors, or at least people who&#8217;ve dug in enough to learn Git internals. But it&#8217;s hardly consistent, even when viewed through that&nbsp;lens.</p>
<h2>Yes, the Git conceptual model is&nbsp;complicated.</h2>
<p>And yeah, unfortunately eventually you&#8217;re exposed to all of it. And yeah, it sucks. As I&#8217;ve <a href="/2012/06/10/git-vs-mercurial-again/">said before</a>, &#8220;I think part of the problem I have with Git, though, is that is often <em>does</em> feel necessary to understand how it&nbsp;works.&#8221;</p>
<p>Personally I think this can be addressed with better visual tools rather than using the command line itself. For example, as I pointed out in my previous comparison of Mercurial and Git, the stage itself is abstracted away by many Git&nbsp;tools:</p>
<blockquote>
<p>I do not understand the allure of the stage. Given how easy Git makes branching, and how straightforward it is to commit, ammend the commit, <code>rebase</code> branches, rewrite history with interactive <code>rebase</code>, etc. what exactly is the advantage of the stage? Most tools don&#8217;t even expose it &#8211; it&#8217;s just there behind the scenes &#8211; so I&#8217;m not sure why people make such a big deal about it all the&nbsp;time.</p>
</blockquote>
<p>That said, the sheer volume of things you can <em>do</em> with Git make it extremely frightening to unfamiliar developers, and since no Git tool does <em>everything</em> Git does, eventually you end up needing to use the command line for something, and you&#8217;re right back at square&nbsp;one.</p>
<p>Now let&#8217;s talk about the places where I disagree with&nbsp;Bennett.</p>
<h2>Git is not &#8220;unsafe version&nbsp;control.&#8221;</h2>
<p><span class="caps">OK</span>, this is blatant emotional manipulation. &#8220;Git is unsafe!&#8221; &#8220;Git will eat all of your code and you&#8217;ll never ever be able to get it back!&#8221; &#8220;Arghhh! Run for the hills!&#8221; Come on. I read a headline like &#8220;Unsafe version control&#8221; and I feel like I am watching an 11 o&#8217;clock news report about &#8220;Escalators: The silent&nbsp;killer.&#8221;</p>
<p>In his <a href="http://www.youtube.com/watch?v=4XpnKHJAok8">Google tech talk</a>, Torvalds talks a lot about the fact that Git&#8217;s decentralization means that often changes you might have eradicated will still exist in another person&#8217;s clone of your repository. <span class="caps">OK</span>, fine, that&#8217;s true, (and can be a good or bad thing depending on one&#8217;s perspective) but I don&#8217;t think that relying on there being another clone with changes that you care about puts many people&#8217;s minds at ease. In fact, I would say fairly confidently, though I don&#8217;t have any data to back this up, that the lion&#8217;s share of projects stored in Git do <em>not</em> have a great volume of clones sitting on computers around the world. Relying on other people&#8217;s clones is not good backup practice in my&nbsp;opinion.</p>
<p>However, Git has a <em>ton</em> of safeguards in place to prevent you from doing damage. First, if you don&#8217;t push, no one even sees your mistake. Second, if you try to push, Git by default won&#8217;t let you if you have divergent changes (as you will if you do a <code>rebase</code> in many cases, for example). You have to explicitly tell it to force push in that scenario. Those are two rather silly examples, but there are others. The reflog itself can help you correct damage you&#8217;ve&nbsp;done.</p>
<p>I think it&#8217;s fair to say that it&#8217;s easier than it should be to get in a state you don&#8217;t want to or didn&#8217;t expect to be in, but it&#8217;s unfair to say that those are unrecoverable situations. I also think that one&#8217;s feelings about Git&#8217;s behavior has more to do with one&#8217;s past experience than it does with Git itself. I&#8217;ll get back to that notion in a&nbsp;moment.</p>
<h2>Comparing Git to Subversion or <span class="caps">CVS</span> directly is&nbsp;dangerous.</h2>
<p>It wasn&#8217;t until his tenth and final point that I really understood why Bennett is getting hung up on some&nbsp;things:</p>
<blockquote>
<p>The point of working on an open source project is to make some changes, then share them with the world. In Subversion, this looks&nbsp;like:</p>
<ol>
<li>Make some&nbsp;changes</li>
<li>svn&nbsp;commit</li>
</ol>
<p>If your changes involve creating new files, there’s a tricky extra&nbsp;step:</p>
<ol>
<li>Make some&nbsp;changes</li>
<li>svn&nbsp;add</li>
<li>svn&nbsp;commit</li>
</ol>
<p>For a GitHub-hosted project, the following is basically the bare&nbsp;minimum:</p>
<ol>
<li>Make some&nbsp;changes</li>
<li>git add (not to be confused with svn&nbsp;add)</li>
<li>git&nbsp;commit</li>
<li>git&nbsp;push</li>
</ol>
<p>Your changes are still only halfway there. Now login to GitHub, find your commit, and issue a “pull request” so that someone downstream can merge&nbsp;it.</p>
</blockquote>
<p>Ummm, <span class="caps">OK</span>&#8230; I&#8217;ll forgive the conflation of GitHub with Git &#8211; they are <em>not</em> the same thing &#8211; because, hey, most Git code in the world today is probably hosted on GitHub in some fashion. But this comparison is fundamentally flawed. Look, we&#8217;re working with a decentralized system. In the old world, committing and sharing were analogous, because it wasn&#8217;t possible to decouple the two actions. Now it is. That brings with it tremendous value and flexibility. But it does mean that there are two separate&nbsp;steps:</p>
<ol>
<li>Writing/committing/adding/merging/blah blah blah&nbsp;code.</li>
<li><em>Sharing</em> that code with other&nbsp;people.</li>
</ol>
<p>You absolutely must understand that Git (and Mercurial) are not centralized systems. They just aren&#8217;t. They weren&#8217;t meant to be. I believe that the decentralized model is better, but if you don&#8217;t, that&#8217;s fine. But the danger in comparing a centralized system to a decentralized one is that fundamental assumptions about behavior can&#8217;t be made. <em>Of course</em> Git doesn&#8217;t automatically throw your changes up for the world to see the moment you commit them. You haven&#8217;t said they&#8217;re ready to&nbsp;share.</p>
<p>Now admittedly this is more steps than the Subversion model &#8211; if your intent is to immediately share all code you commit. That feels so incredibly dangerous to me that I would freak out a little bit if working on a system like that, but&#8230; that&#8217;s just&nbsp;me. </p>
<h2>Let&#8217;s talk about&nbsp;defaults.</h2>
<p>In software design, we think an awful lot about so-called &#8216;intelligent defaults.&#8217; The default settings of an application should work for 80-90% of users&#8217; needs. Fewer settings = fewer choices = better experience. This applies just as well to a command line application as it does to an app with a&nbsp;<span class="caps">GUI</span>.</p>
<p>But choosing intelligent defaults is incredibly difficult, even when your application&#8217;s purpose is narrowly scoped. In the case of version control, as Bennett points out, there are myriad different ways to handle your development process. While some of that is informed by your <span class="caps">VCS</span>, ideally you&#8217;ll be able to make your <span class="caps">VCS</span> match your process, not the other way around. Mercurial actually has <a href="http://mercurial.selenic.com/wiki/MultipleCommitters">an overview of some of the common models</a> and how Mercurial can be used within&nbsp;them.</p>
<p>So with this in mind, Git has an impossible problem, because the nature of development is that <em>there is no one way to do things.</em> Heck, one of the reasons Torvalds wrote Git (beyond the Bitkeeper issues) is that the current <span class="caps">VCS</span> solutions didn&#8217;t meet the needs of the kernel development&nbsp;process.</p>
<p>Whatever defaults Git chooses (even if it miraculously became consistent overnight, which it won&#8217;t because of that nasty little thing we all despise as engineers but continue to care about on our users&#8217; behalf called &#8216;backwards compatibility&#8217;) won&#8217;t be appropriate for a lot of &#8211; possibly a majority of &#8211; projects. And since you, the new contributor, don&#8217;t have a lot of say in how the development model of the project works, you don&#8217;t have a lot of say in how Git &#8211; or Subversion, or Mercurial, or whatever other <span class="caps">VCS</span> &#8211; is used there&nbsp;either.</p>
<p><span class="dquo">&#8220;</span>But couldn&#8217;t they add a mode to Git that would emulate Subversion for <span class="caps">SVN</span> users and Mercurial for Mercurial users etc. etc,&#8221; you might say? Perhaps, though <a href="http://blogs.msdn.com/b/oldnewthing/archive/2003/07/28/54583.aspx">I&#8217;m not sure it would work out that well</a>. <a href="http://people.gnome.org/~newren/eg/">Easy <span class="caps">GIT</span></a> seems like an effort for Subversion folks that&#8217;s worth looking at more deeply, but its mere existence serves as proof that the notion of &#8216;intelligent defaults&#8217; depends a heck of a lot on your&nbsp;perspective.</p>
<p>Having written all of this, I think Bennett has an excellent point when he writes &#8211; in <a href="https://steveko.wordpress.com/2012/02/24/10-things-i-hate-about-git/#comment-82">his reponse to a comment</a>:</p>
<blockquote>
<p>The annoying thing about <span class="caps">VCS</span>, compared to say, an editor, is that the basic rule of “if you don’t like it, use something else” doesn’t apply. (So in my case, since I never start open source projects, I’ll never get to choose a Git&nbsp;alternative.) </p>
</blockquote>
<p>That truly is a problem. You have to play by other people&#8217;s rules if you want to join their game, which means you have to learn &#8211; or relearn &#8211; some things. I personally welcome learning new things as a general rule, but perhaps I am unique or unusual in that&nbsp;regard.</p>
<h2>Git history is <em>not</em> a bunch of&nbsp;lies.</h2>
<p>First, let me disclose my bias here. I am <strong>sick and tired</strong> of this &#8216;indelible history&#8217; idea that people seem married to. When your mom asks you what you did this weekend do you tell her that you hooked up with two chicks from the bar for a drunken tryst? Do you go into great detail about the depths of depravity you participated in that night? Probably not. The &#8216;radical honesty&#8217; thing, when it comes to source history, is detrimental. Some &#8216;lies&#8217; are&nbsp;useful.</p>
<p>Likewise, I don&#8217;t need to expose you to my mental process for development. I&#8217;ve said&nbsp;before:</p>
<blockquote>
<p>I am <em>all over the place</em> when I code. While I believe that source history should be the <em>&#8216;truth,&#8217;</em> I also think that above all, it should be as easy to follow as possible. Commit messages are an important part of this, of course, but cleaning up your local history before you share it is critical too. You can go back through and tie up loose ends, remove unnecessary code changes you made,&nbsp;etc.</p>
</blockquote>
<p>If I&#8217;m writing an article for tylerbutler.com, I write write write write write. Then I take a break and I edit. And I repeat that process until I think things are in good enough shape to share with people. Obviously I&#8217;ll make some more edits after I&#8217;ve shared it if I or others find flaws after the fact. But if I missed a comma before I shared the article, you don&#8217;t need to know about it. Similarly, I don&#8217;t sit here at my desk in fear, never hitting Ctrl-S, because I&#8217;m worried that everything is not <em>just right</em> and delaying saving my&nbsp;work.</p>
<p>But in the centralized <span class="caps">VCS</span> world, that&#8217;s what writing code is like, because there are two intents implied by committing. One, that the change is sound, and two, that the change is ready to be shared with everyone. If every time I saved a draft article it went live immediately on my site it would dramatically change the way I write. I wouldn&#8217;t save very often. I would save my work somewhere else then copy it to the site when it was done. I would essentially work around the save-goes-live-immediately system because it&#8217;s dangerous. Or worse, I would work within its bounds and <em>never</em> save until everything was perfect, risking an awful lot of lost&nbsp;work.</p>
<p>I <em>love</em> <code>rebase</code>, and the interactive variety, specifically because it lets me &#8216;save&#8217; often with the ability to edit my insanity after the fact. It let&#8217;s me vomit out ideas then clean them up later. Am I the only person in the entire world that works this way? Sometimes I definitely feel like&nbsp;it.</p>
<p>Now, you can argue that for my use-case patches are a better solution, but I prefer just committing them directly to Git for a very simple reason: I can push the changes. &#8220;But wait!&#8221; you&#8217;ll say. &#8220;Pushing half-baked changes is what you&#8217;re trying to avoid! Haha! You&#8217;re such a hypocrite!&#8221; Well, no, not exactly. I said I don&#8217;t want to <em>share</em> half-baked changes. And I know it&#8217;s a little crazy, but sharing and <code>git push</code> are not the same thing.<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup></p>
<p>See, I develop on several different machines in several different locations. Try as I might, I can&#8217;t always complete a piece of development on a single machine. So I need to synchronize my in-progress work. One way to look at it is that I need to share with&nbsp;myself.</p>
<p>Sharing with myself is different. There are different rules and different intentions. Git lets me do this easily by having a separate repository clone that is all mine. This is one thing I think GitHub could make a lot better, but as it stands I have my own Git repositories on <a href="http://www.webfaction.com/?affiliate=tylerbutler">WebFaction</a>, and I push to them whenever I want. They&#8217;re mine. And my changes follow me anywhere I go (sort of &#8211; there are some problems I have which I&#8217;ll get into another time). But when I&#8217;m ready to <em>share</em> my changes &#8211; not push &#8211; then I <code>git push</code> to the central shared repository. And you don&#8217;t know &#8211; nor should you even care &#8211; that I made those changes over the course of three days on six different machines. By the time the changes get to you, they&#8217;re tidy, they&#8217;re tightly scoped, and they&#8217;re easy to understand. Do you <em>really</em> not hold other developers to that same&nbsp;standard?</p>
<p>Version history is absolutely important. When working with a group of developers, it&#8217;s essential. But while I can&#8217;t promise that I&#8217;ll always share perfect and bug-free code with you, I <em>can</em> promise that I won&#8217;t expose you to the insanity that is going on inside my head, and in the code-base, when I&#8217;m coding up a&nbsp;fix.</p>
<p>At this point I have digressed quite a bit. But let me leave you with one final thought, given that it seems several of Bennett&#8217;s issues stem from his centralized <span class="caps">VCS</span>&nbsp;background:</p>
<h2>As a developer you <strong>must</strong> learn to use decentralized version control&nbsp;systems.</h2>
<p>There is no excuse. It is a basic tool of your profession. Few carpenters get by without learning how to use a lathe; you can&#8217;t get by without understanding <span class="caps">DVCS</span>. I don&#8217;t care if you love <span class="caps">SVN</span>, or you use <span class="caps">TFS</span> at work, or you think Git is terrible because its command line is an exercise in insanity. <strong>Learn something.</strong> Mercurial is fine. Git is fine. Heck, even Bazaar is fine as far as I&#8217;m concerned. But, for just a moment, forget everything you know about version control and get a grasp of some of the basic concepts of&nbsp;<span class="caps">DVCS</span>.</p>
<p>Joel Spolsy&#8217;s <a href="http://hginit.com">Hg Init</a> site is a good place to start. Yeah, it&#8217;s Mercurial-centric, but that&#8217;s fine. The concepts are similar to Git or any other <span class="caps">DVCS</span>. And if you like what you see, perhaps you&#8217;ll try using Mercurial instead of Git. That&#8217;s <span class="caps">OK</span> too. For the brain-damaged among you, Joel even has <a href="http://hginit.com/00.html">a section</a> for folks with a Subversion&nbsp;background:</p>
<blockquote>
<p>It turns out that if you’ve been using Subversion, your brain is a little bit, um, how can I say this politely? You’re brain damaged. No, that’s not polite. You need a little re-education. I walked around brain damaged for six months thinking that Mercurial was more complicated than Subversion, but that was only because I didn’t understand how it really worked, and once I did, it turns out—hey presto!—it’s really kind of&nbsp;simple.</p>
<p>So I wrote this tutorial for you, in which I have been very careful not to explain things in terms of Subversion, because there is just no reason to cause any more brain damage. The world is brain damaged enough. Instead, for those of you who are coming from Subversion, I’ve got this one chapter at the beginning that will try to reverse as much damage as possible so that you can learn Mercurial from a clean&nbsp;slate.</p>
</blockquote>
<p>The future is waiting. Go meet&nbsp;it.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Bennett uses this example, which is&nbsp;apt:</p>
<blockquote>
<p>To reset one file in your working directory to its committed&nbsp;state:</p>
<div class="codehilite"><pre>git checkout file.txt
</pre></div>


<p>To reset every file in your working directory to its committed&nbsp;state:</p>
<div class="codehilite"><pre>git reset --hard
</pre></div>


</blockquote>
<p><a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>I <em>know</em> that closed-source software has this same problem. How do you bring a new developer up to speed on the codebase? Every software development shop has to solve that problem <em>somehow.</em> However, in those cases, the problem is not publically evident since we, the public, don&#8217;t see the &#8216;internal developer documentation,&#8217; if it exists.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>In fact, I&#8217;ve thought about trying to wrap my development process in some scripts, sort of like git-flow, but it&#8217;s likely overkill. I find it hard to believe I&#8217;m the only person in the world that works this way, but maybe I am. No other developer codes on more than one machine? Goodness gracious.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>
                                                                                                                
                    <div class="row">
                        <div class="twelve columns post-links">
                            <ul class="block-grid two-up">
                                <li>
                                                                            <a href="/2012/07/max-css/">← Max CSS</a>
                                                                    </li>
                                <li>
                                                                            <a href="/2012/08/engineer-0-3-1-released/">Engineer 0.3.1 Released →</a>
                                                                    </li>
                            </ul>
                        </div>
                    </div>
                                            </article>
            </div></section>
            </div>
        <div class="row">                <footer class="twelve columns centered">                        <p>&copy; 2002-2013 Tyler Butler. All rights reserved.</p>

<p>Powered by <a href="http://www.tylerbutler.com/projects/engineer">engineer</a>.</p>                    </footer>
            </div>
    </div>
                <script src="/static/engineer/lib/foundation/javascripts/foundation.js"></script>
        
    
    
</body>
</html>